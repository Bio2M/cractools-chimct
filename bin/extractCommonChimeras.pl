#! /usr/bin/perl
## author: nicolas PHILIPPE
## email: nicolas.philippe@inserm.fr
## goal: extract common chimeras detected after the chimeraPipeline process of crac-utils

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use CracTools::Output;

use constant MAX_PRINT_NAME       => 10;
use constant MAX_PRINT_REDUNDANCY => 45;
use constant NA                   => "N/A";
=head1 NAME

    extractCommonChimeras.pl - Extract common chimeras from a list of csv files generated by chimCT. By default, we only considers redundant chimeras (at least in two different samples) but the threshold can be modified.

=head1 SYNOPSIS

    extractCommonChimeras.pl [-h] [--min-ranking <score>] [--threshold <min_redundancy>] [--summary <output_file>] [--output <output_file>]  [--Rdata <output_file>] <file1.csv> <file2.csv> ... <filen.csv>
    The mandatory arguments are at least two csv files generated by chimeraPipeline.
    --output: put the filename to write the results (STDOUT by default)
    --min-ranking: a minimal rank to consider the chimera (0 by default, ie no minimal rank)
    --threshold: the minimal redundancy to consider a redundant chimera, ie the min number of  
                 different samples where a same chimera is found (2 by default)
    --summary: make some statistics in the output_file if the argument is defined
    --Rdata: format the statistics for R graphics in the output_file if the argument is defined
    --filter: a files containing chimeras id (one by line) to be filtered-out

=head1 OPTIONS
    
    -h, --help
    --min-score=I<score>
    --summary=I<output_FILE>
    --threshold=I<min_redundancy>
    --Rdata=I<output_FILE>

=head1 OUTPUT FORMAT

This is a descrition of the fields of the output file format. Each line correspond to a redundant chimera
identified and annotated by the chimeraPipeline. Chimeras are ordered by Score, Class and number
of redundant chimeras.

=over

=item 1  B<Id>                 - A Uniq Id for each chimera. This id is composed by C<sample_name:chimera id>.

=item 2  B<Name>               - Fusion genes names separated by three dashes ('---')

=item 3  B<Chr1>               - Chromosome of the 5' part of the chimera

=item 4  B<Pos1>               - Genomic positions of the 5' part of the chimera

=item 5  B<Strand1>            - Genomic strand of the 5' part of the chimera. If sample is not C<--stranded>
                              No assumption can be made about the strand

=item 6  B<Chr2>               - Chromosome of the 3' part of the chimera. Same as I<Chr2>, unless it is a class 1 chimera (translocation).

=item 7  B<Pos2>               - Genomic positions of the 3' part of the chimera

=item 8  B<Strand2>            - Genomic strand of the 3' part of the chimera. If sample is not C<--stranded>
                              No assumption can be made about the strand

=item 9  B<Average_Rank>       - Average rank of all redundant chimeras. 
                              The rank is based on confidence about chimera's positivity (add more details)

=item 10 B<Class>              - Chimeric class from 1 to 4. (add more details)

=item 11 B<Redundancy>         - The redundancy for a given chimera correponds to the number of different sample where the chimera is found

=item 12 B<Listof (Sample,Spanning_junction,Spanning_PE,Rank)>      
                               - Sample identified the experiment
                                 Spanning junction read that contains the chimeric junction 
                                 Spanning paired-end reads that contains the chimeric junction but in the non-sequenced part
                                 Rank computed by the chimeraPipeline for the chimera in that Sample

=item 13 B<Comments>           - Several comments about the chimera and the rank computed

=back

=head1 DESCRIPTION
    
    This script permets to group redondant chimeras between different samples and conditions. 

=head1 REQUIRES

    Perl5.
    Getopt::Long
    Pod::Usage
    
=head1 AUTHOR

    Nicolas PHILIPPE <nicolas.philippe@inserm.fr>

=cut   


my ($help, $min_score, $summary_file, $min_redundant, $output_file, $r_file, $filter_file) = (0, 0, undef, 2, undef, undef);

GetOptions( "min-ranking=i" => \$min_score,
	    "threshold=i" => \$min_redundant,
	    "summary=s" => \$summary_file,
	    "output=s" => \$output_file,
	    "Rdata=s" => \$r_file,
      "filter=s" => \$filter_file,
	    "help" => \$help,
        ) or pod2usage(-verbose => 0);

pod2usage(-verbose => 0)  if ($help);


if (scalar @ARGV < 2){
    pod2usage(-verbose => 0);
    exit 1;
}

my %hash;
my %hashsample;
my $nb_sample = 0;
my $samples;
my $total_chim = 0;

# If there is a filter file, create a hash to filter-out chimeras
my %filter_chimeras;

# Read filter file if set in argument
# leave open warn if can not read it
if (defined $filter_file) {
  open(IN,$filter_file) or die("Cannot open $filter_file");
  while(<IN>) {
    next if $_ =~ /^#/;
    chomp;
    if ($_ =~ /^\S+:(\S+)/){
      $filter_chimeras{$1}++;
    }
  }
}

# store info for recurrent chimeras
while (my $file = shift @ARGV){
    open(IN,$file) or die("enable to open $file");
    my $new_sample = 1;
    my ($analysed, $chim,$span_j,$span_PE);
    while(<IN>){
	chomp;
	if ($_ !~ /^#/){
	    my ($ids,$name,$chr1,$pos1,$strand1,$chr2,$pos2,$strand2,$score,$spanJ,$spanR,$class,$comments,@others) = split(/\t/,$_);
	    my ($sample,$id) = split(/:/,$ids);

      # Filter chimeras
      next if defined $filter_chimeras{$id};
	    
	    # store sample features for headers
	    if ($new_sample == 1){
		$hashsample{$sample}{'COUNT'}{'ANALYSED'} = $analysed;
		$hashsample{$sample}{'COUNT'}{'CHIMERA'} = $chim;
		$hashsample{$sample}{'COUNT'}{'SPANJ'} = $span_j;
		$hashsample{$sample}{'COUNT'}{'SPANPE'} = $span_PE;
		$new_sample = 0;
		if ($nb_sample == 0){
		    $samples = "$sample";
		}else{
		    $samples .= ",$sample";
		}
		$nb_sample++;
	    }

	    # store features by chimera
	    if (defined $hash{$id}){ 
		$hash{$id}{'SCORE'} += $score; 
		$hash{$id}{'COUNT'}++;
		$hash{$id}{'SAMPLE'} .= ";($sample,".$spanJ.",".$spanR.",".$score.")";
	    }else{
		$total_chim++;
		$hash{$id}{'SCORE'} = $score;
		$hash{$id}{'CLASS'} = $class;
		$hash{$id}{'COUNT'} = 1;
		$hash{$id}{'SAMPLE'} = "($sample,".$spanJ.",".$spanR.",".$score.")";
		$hash{$id}{'FEATURES'} = $ids."\t".$name."\t".$chr1."\t".$pos1."\t".$strand1."\t".$chr2."\t".$pos2."\t".$strand2; 
    $hash{$id}{'OTHERS'} = \@others;
	    }

            # reparting and counting comments for a same chimera
	    if (defined $comments){
		my @comments_tmp = split(/,/,$comments);
		foreach my $comment (@comments_tmp){
		    $hash{$id}{'COMMENTS'}{$comment}++;
		}
	    }
	}else{
	    if ($_ =~ /^#\s+Nb\s+total/){
		($analysed) = $_ =~ /^\D+(\d+)$/;
	    }elsif ($_ =~ /^#\s+Nb\s+chimeras/){
		($chim) = $_ =~ /^\D+(\d+)$/;
	    }elsif ($_ =~ /^#\s+Nb\s+spanning\s+junction/){
		($span_j) = $_ =~ /^\D+(\d+)$/;
	    }elsif ($_ =~ /^#\s+Nb\s+spanning\s+PE/){
		($span_PE) = $_ =~ /^\D+(\d+)$/;
	    }
	}
    }
    close(IN);    
}

foreach my $key (keys %hash) {
    if ($hash{$key}{'COUNT'} >= $min_redundant){
	# computing of the average score and building comments column
	my $total = $hash{$key}{'COUNT'}; 
	my $average_score = $hash{$key}{'SCORE'};
	$hash{$key}{'SCORE'} = int($average_score/$total + 0.5);
	foreach my $key2 (keys %{ $hash{$key}{'COMMENTS'} }) {
	    if (!defined $hash{$key}{'COMMENTS'}{'TOTAL'}){
		$hash{$key}{'COMMENTS'}{'TOTAL'} = $hash{$key}{'COMMENTS'}{$key2}."x".$key2;
	    }else{
		$hash{$key}{'COMMENTS'}{'TOTAL'} .= ",".$hash{$key}{'COMMENTS'}{$key2}."x".$key2;
	    }
	}
	if (!defined $hash{$key}{'COMMENTS'}{'TOTAL'}){
	    $hash{$key}{'COMMENTS'}{'TOTAL'} = NA;
	}
	
	# delete the element for small scores
	if ($hash{$key}{'SCORE'} < $min_score){
	    delete $hash{$key};
	}
	# store features by sample
	else{
	    my $class = $hash{$key}{'CLASS'};
	    my @samples = split(/;/,$hash{$key}{'SAMPLE'});
	    my ($name) = $hash{$key}{'FEATURES'} =~ /^\S+\s+(\S+)\s/;
	    foreach my $key (@samples){
		my ($samp) = $key =~ /^\((\S+?),/;
		if (defined $hashsample{$samp} && defined $hashsample{$samp}{'CHIMERA'}{$class}){
		    $hashsample{$samp}{'CHIMERA'}{$class} .= ",$name";
		}else{
		    $hashsample{$samp}{'CHIMERA'}{$class} .= "$name";
		}
		$hashsample{$samp}{'COUNT'}{$class}++;
		$hashsample{$samp}{'COUNT'}{'TOTAL'}++;
	    }
	}
    }
    # delete the element not enough redundant
    else{
	delete $hash{$key};
    }
}


# print results
my $output = CracTools::Output->new(file => $output_file);
$output->printHeaders(args => \@ARGV);
$output->printHeaderLine("Goal: cross common chimera in $nb_sample different samples: $samples");
$output->printHeaderLine();
$output->printHeaderLine("Id\tFusion_genes(left-right)\tChr1\tPos1\tStrand1\t\tChr2\tPos2\tStrand2\tAverage_rank\tClass\tRedundancy\tList_of_(Sample,Spanning_junction,Spanning_PE,Rank)\tComments\tOthers");
foreach my $key (sort { $hash{$b}{'SCORE'} <=> $hash{$a}{'SCORE'} || $hash{$a}{'CLASS'} <=> $hash{$b}{'CLASS'} || $hash{$b}{'COUNT'} <=> $hash{$a}{'COUNT'} } keys %hash) {
    $output->printLine($hash{$key}{'FEATURES'},$hash{$key}{'SCORE'},$hash{$key}{'CLASS'},$hash{$key}{'COUNT'},$hash{$key}{'SAMPLE'},$hash{$key}{'COMMENTS'}{'TOTAL'},@{$hash{$key}{'OTHERS'}});
}

# format data for R
if (defined $r_file){
    my %hash_isoform;
    open(R,">$r_file") or die("enable to open $r_file");
    print R "# format data for heatmap graphics\n";
    print R "Name\tSample\tCover\tRank\tClass\n";
    foreach my $key (keys %hash) {
	my @samples = split(/;/,$hash{$key}{'SAMPLE'});
	my ($name) = $hash{$key}{'FEATURES'} =~ /^\S+\s+(\S+)\s/;
	if (defined $hash_isoform{$name}){
	    $name .= "(".$hash_isoform{$name}.")";
	    $hash_isoform{$name}++;
	}else{
	    $hash_isoform{$name} = 1;
	}
	my $class = $hash{$key}{'CLASS'};
	foreach my $features (@samples){
	    my ($sample,$spanJ,$spanPE,$score) = $features =~ /^\((\S+?),(\S+?),(\S+?),(\S+?)\)/;
	    my $rank = int($score + 0.5);
	    my $cover = $spanPE + $spanJ;
	    print R "$name\t$sample\t$cover\t$rank\t$class\n";
	}
    }
    close(R);
}




################################ SUMMARY ################################


if (defined $summary_file){
    my $total_retained = 0;
    my %hash_stats;
    foreach my $key (keys %hash) {
	$total_retained++;
	
	my $redondant = $hash{$key}{'COUNT'};
	my $score = $hash{$key}{'SCORE'};
	my $class = $hash{$key}{'CLASS'};
	
	$hash_stats{'SCORE'}{$score}++;
	$hash_stats{'CLASS'}{$class}++;
	if (defined $hash_stats{'REDUNCLASS'}{$redondant}){
	    $hash_stats{'REDUNCLASS'}{$redondant} .= ",$class";
	}else{
	    $hash_stats{'REDUNCLASS'}{$redondant} .= "$class";
	}
	$hash_stats{'REDUNDANT'}{$redondant}++;
    }
    my $total_deleted = $total_chim - $total_retained;
    
    open(OUT, ">$summary_file") or die("enable to open $summary_file");
    print OUT "#some statistics about $total_chim different redundant chimeras in $nb_sample different samples\n";
    print OUT "#note that $total_deleted chimeras are deleted because of a rank < $min_score or a minimal redundancy < $min_redundant\n";
    print OUT "#date: ".localtime()."\n";
    print OUT "#\n";
    print OUT "#statistics by rank:\n";
    print OUT "#rank\tnumber\n";
    foreach my $elt (sort {$hash_stats{'SCORE'}{$b} <=> $hash_stats{'SCORE'}{$a}} 
		     keys %{ $hash_stats{'SCORE'}}){
	print OUT "$elt\t".$hash_stats{'SCORE'}{$elt}."\n";
    }
    print OUT "#\n";
    print OUT "#statistics by class:\n";
    print OUT "#class\tnumber\n";
    foreach my $elt (sort {$hash_stats{'CLASS'}{$b} <=> $hash_stats{'CLASS'}{$a}} 
		     keys %{ $hash_stats{'CLASS'}}){
	print OUT "$elt\t".$hash_stats{'CLASS'}{$elt}."\n";
    }
    print OUT "#\n";
    print OUT "#statistics by nb_redundant chimeras:\n";
    print OUT "#redundancy\tnumber\t(list of different classes)\n";
    foreach my $elt (sort {$hash_stats{'REDUNDANT'}{$b} <=> $hash_stats{'REDUNDANT'}{$a}} 
		     keys %{ $hash_stats{'REDUNDANT'}}){
	if ($hash_stats{'REDUNDANT'}{$elt} < MAX_PRINT_REDUNDANCY){
	    print OUT "$elt\t".$hash_stats{'REDUNDANT'}{$elt}."\t".$hash_stats{'REDUNCLASS'}{$elt}."\n";
	}else{
	    my @redunclass = split(/,/,$hash_stats{'REDUNCLASS'}{$elt});
	    print OUT "$elt\t".$hash_stats{'REDUNDANT'}{$elt}."\t".join(",", @redunclass[0..MAX_PRINT_REDUNDANCY-1]).",...//\n";
	}
    }
    print OUT "#\n";
    print OUT "#statistics by sample:\n";
    print OUT "#sample\tnumber_reads\tnumber_chimeras\tnumber_spanj\tnumber_spanPE\tnumber_redundant_chimeras\n";
    foreach my $elt (keys %hashsample){
	my $total = defined $hashsample{$elt}{'COUNT'}{'TOTAL'} ? $hashsample{$elt}{'COUNT'}{'TOTAL'} : 0;  
	print OUT "$elt\t".$hashsample{$elt}{'COUNT'}{'ANALYSED'}."\t".$hashsample{$elt}{'COUNT'}{'CHIMERA'}."\t".$hashsample{$elt}{'COUNT'}{'SPANJ'}."\t".$hashsample{$elt}{'COUNT'}{'SPANPE'}."\t".$total."\n";
    }
    print OUT "#\n";
    print OUT "#statistics by sample and by class:\n";
    print OUT "#sample\tclass\tnumber\t(list of different chimeras)\n";
    foreach my $elt (keys %hashsample){
	print OUT "$elt\n";
	for (my $i=1 ; $i <= 4 ; $i++){
	    if (defined $hashsample{$elt}{'COUNT'}{$i}){
		if ($hashsample{$elt}{'COUNT'}{$i} < MAX_PRINT_NAME){
		    print OUT "\t".$i."\t".$hashsample{$elt}{'COUNT'}{$i}."\t".$hashsample{$elt}{'CHIMERA'}{$i}."\n";
		}else{
		    my @chim = split(/,/,$hashsample{$elt}{'CHIMERA'}{$i});
		    print OUT "\t".$i."\t".$hashsample{$elt}{'COUNT'}{$i}."\t".join(",", @chim[0..MAX_PRINT_NAME-1]).",...//\n";
		}
	    }else{
		print OUT "\t".$i."\t".NA."\t".NA."\n";
	    }
	}
    }
    print OUT "#\n";
    close(OUT);
}
